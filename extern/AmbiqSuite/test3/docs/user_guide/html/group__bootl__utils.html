<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AmbiqSuite User Guide: Bootloader Utility</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
<link href="paramAlign.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="am_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">AmbiqSuite User Guide<span id="projectnumber">&#160;SDK 5.2.alpha.1.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Bootloader Utility<div class="ingroups"><a class="el" href="group__utils.html">utils</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Purpose: This module provides a bootloader utility library for managing firmware images, flash operations, and system initialization across Ambiq Micro devices. It enables secure firmware updates, image validation, CRC-32 verification, and flash programming operations for embedded applications requiring reliable boot processes. The utilities support encrypted and clear image handling, flag page management, and features like partial CRC calculation and image structure validation for optimal system reliability and firmware deployment.</p>
<h1><a class="anchor" id="bootl_features"></a>
Key Features</h1>
<ol type="1">
<li><b>Image</b> <b>Validation:</b> Comprehensive firmware image integrity checking.</li>
<li><b>CRC-32</b> <b>Verification:</b> Fast and efficient CRC-32 calculation for data integrity.</li>
<li><b>Flash</b> <b>Operations:</b> Secure flash programming, erasing, and management.</li>
<li><b>Encrypted</b> <b>Support:</b> Handling of both encrypted and clear firmware images.</li>
<li><b>GPIO</b> <b>Override:</b> Manual override capabilities for testing and debugging.</li>
<li><b>Flag</b> <b>Page</b> <b>Management:</b> Bootloader flag page operations and updates.</li>
</ol>
<h1><a class="anchor" id="bootl_functionality"></a>
Functionality</h1>
<ul>
<li>Validate firmware images for safe execution</li>
<li>Perform CRC-32 calculations on image data</li>
<li>Manage flash memory operations (erase, program, write)</li>
<li>Handle encrypted and clear image formats</li>
<li>Support GPIO override for manual testing</li>
<li>Update bootloader flag pages with new image references</li>
<li>Execute validated firmware images</li>
<li>Validate information structure integrity</li>
</ul>
<h1><a class="anchor" id="bootl_usage"></a>
Usage</h1>
<ol type="1">
<li>Initialize bootloader utilities for target device</li>
<li>Validate firmware image using <a class="el" href="#gaea8a729bf77564c20ca7ec3ac40c7a0c" title="Checks a boot image to make sure it&#39;s safe to run.">am_util_bootloader_image_check()</a></li>
<li>Update flag page with <a class="el" href="#ga43bd170339032395a3fecb6882241c73" title="Updates the bootloader flag page with a new image pointer.">am_util_bootloader_flag_page_update()</a></li>
<li>Program flash using <a class="el" href="#ga817fe77346358e2bd670850dff8be278" title="Reprogram a flash page.">am_util_bootloader_program_flash_page()</a></li>
<li>Execute validated image with <a class="el" href="#ga8056ade7032e6d46a798f57512431c30" title="Execute an image that has already been written to flash.">am_util_bootloader_image_run()</a></li>
</ol>
<h1><a class="anchor" id="bootl_configuration"></a>
Configuration</h1>
<ul>
<li><b>BOOTLOADER_DEBUG:</b> Enable/disable debug output and GPIO indicators</li>
<li><b>Device</b> <b>Support:</b> Apollo3, Apollo3P, Apollo4, Apollo4B, Apollo4L, Apollo4P, Apollo510</li>
<li><b>Flash</b> <b>Memory:</b> Support for different flash memory types and sizes</li>
<li><b>CRC</b> <b>Polynomial:</b> CRC-32C polynomial (0x1EDC6F41) for error detection</li>
<li><b>GPIO</b> <b>Configuration:</b> Override pin configuration for manual testing</li>
</ul>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structam__util__bootloader__image__t.html">am_util_bootloader_image_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga269dbb08c6c6e9ef5bb9e2e7b10e0986" id="r_ga269dbb08c6c6e9ef5bb9e2e7b10e0986"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga269dbb08c6c6e9ef5bb9e2e7b10e0986">DPRINTF</a>(x)</td></tr>
<tr class="separator:ga269dbb08c6c6e9ef5bb9e2e7b10e0986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32104fd66e8bf60867719c6b6c877b4b" id="r_ga32104fd66e8bf60867719c6b6c877b4b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga32104fd66e8bf60867719c6b6c877b4b">CRC32_POLYNOMIAL</a>&#160;&#160;&#160;0x1EDC6F41</td></tr>
<tr class="separator:ga32104fd66e8bf60867719c6b6c877b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae25ba564f90bf20efdf87eba084ec484" id="r_gae25ba564f90bf20efdf87eba084ec484"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae25ba564f90bf20efdf87eba084ec484">AM_BOOTLOADER_DISABLE_OVERRIDE_PIN</a>&#160;&#160;&#160;(0xFFFFFFFF)</td></tr>
<tr class="separator:gae25ba564f90bf20efdf87eba084ec484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5564a2fd78f7d87200bcd88695a41c95" id="r_ga5564a2fd78f7d87200bcd88695a41c95"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5564a2fd78f7d87200bcd88695a41c95">AM_BOOTLOADER_OVERRIDE_HIGH</a>&#160;&#160;&#160;(0x1)</td></tr>
<tr class="separator:ga5564a2fd78f7d87200bcd88695a41c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25a37e846ff1306dcc9bc27f400e2741" id="r_ga25a37e846ff1306dcc9bc27f400e2741"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga25a37e846ff1306dcc9bc27f400e2741">AM_BOOTLOADER_OVERRIDE_LOW</a>&#160;&#160;&#160;(0x0)</td></tr>
<tr class="separator:ga25a37e846ff1306dcc9bc27f400e2741"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab072f2ea46afe90b7da77ccdd8500c16" id="r_gab072f2ea46afe90b7da77ccdd8500c16"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab072f2ea46afe90b7da77ccdd8500c16">am_util_bootloader_crc32</a> (const void *pvData, uint32_t ui32NumBytes)</td></tr>
<tr class="memdesc:gab072f2ea46afe90b7da77ccdd8500c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRC-32 implementation for the boot loader.  <br /></td></tr>
<tr class="separator:gab072f2ea46afe90b7da77ccdd8500c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a23f418618ff8d3423a51d17c6563a7" id="r_ga7a23f418618ff8d3423a51d17c6563a7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7a23f418618ff8d3423a51d17c6563a7">am_util_bootloader_fast_crc32</a> (const void *pvData, uint32_t ui32NumBytes)</td></tr>
<tr class="memdesc:ga7a23f418618ff8d3423a51d17c6563a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Faster CRC-32 implementation for the boot loader.  <br /></td></tr>
<tr class="separator:ga7a23f418618ff8d3423a51d17c6563a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74d3f2365b98ae51cb42976a79676f1b" id="r_ga74d3f2365b98ae51cb42976a79676f1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga74d3f2365b98ae51cb42976a79676f1b">am_util_bootloader_partial_crc32</a> (const void *pvData, uint32_t ui32NumBytes, uint32_t *pui32CRC)</td></tr>
<tr class="memdesc:ga74d3f2365b98ae51cb42976a79676f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRC-32 implementation allowing multiple partial images.  <br /></td></tr>
<tr class="separator:ga74d3f2365b98ae51cb42976a79676f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac905290d5b802192e17b3ec13eaa7b2f" id="r_gac905290d5b802192e17b3ec13eaa7b2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac905290d5b802192e17b3ec13eaa7b2f">am_util_bootloader_flash_check</a> (<a class="el" href="structam__util__bootloader__image__t.html">am_util_bootloader_image_t</a> *psImage)</td></tr>
<tr class="memdesc:gac905290d5b802192e17b3ec13eaa7b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the flash contents of a boot image to make sure it's safe to run.  <br /></td></tr>
<tr class="separator:gac905290d5b802192e17b3ec13eaa7b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c8f5274cc9c3fa31191bfd0eaec521d" id="r_ga8c8f5274cc9c3fa31191bfd0eaec521d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8c8f5274cc9c3fa31191bfd0eaec521d">am_hal_bootloader_override_check</a> (<a class="el" href="structam__util__bootloader__image__t.html">am_util_bootloader_image_t</a> *psImage)</td></tr>
<tr class="memdesc:ga8c8f5274cc9c3fa31191bfd0eaec521d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the override GPIO for manual override.  <br /></td></tr>
<tr class="separator:ga8c8f5274cc9c3fa31191bfd0eaec521d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea8a729bf77564c20ca7ec3ac40c7a0c" id="r_gaea8a729bf77564c20ca7ec3ac40c7a0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaea8a729bf77564c20ca7ec3ac40c7a0c">am_util_bootloader_image_check</a> (<a class="el" href="structam__util__bootloader__image__t.html">am_util_bootloader_image_t</a> *psImage)</td></tr>
<tr class="memdesc:gaea8a729bf77564c20ca7ec3ac40c7a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a boot image to make sure it's safe to run.  <br /></td></tr>
<tr class="separator:gaea8a729bf77564c20ca7ec3ac40c7a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a3b3b78fef9c0df8deab63550c79a9e" id="r_ga3a3b3b78fef9c0df8deab63550c79a9e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3a3b3b78fef9c0df8deab63550c79a9e">am_util_bootloader_validate_structure</a> (uint32_t *pInfo, uint32_t <a class="el" href="am__devices__510L__radio_8h.html#ae5dc6ffcd9b7605c7787791e40cc6bb0">size</a>)</td></tr>
<tr class="memdesc:ga3a3b3b78fef9c0df8deab63550c79a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates a information structure integrity.  <br /></td></tr>
<tr class="separator:ga3a3b3b78fef9c0df8deab63550c79a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43bd170339032395a3fecb6882241c73" id="r_ga43bd170339032395a3fecb6882241c73"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga43bd170339032395a3fecb6882241c73">am_util_bootloader_flag_page_update</a> (<a class="el" href="structam__util__bootloader__image__t.html">am_util_bootloader_image_t</a> *psImage, uint32_t *pui32FlagPage)</td></tr>
<tr class="memdesc:ga43bd170339032395a3fecb6882241c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the bootloader flag page with a new image pointer.  <br /></td></tr>
<tr class="separator:ga43bd170339032395a3fecb6882241c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6633d3e4f9d28039e8ecebb9ff615ff7" id="r_ga6633d3e4f9d28039e8ecebb9ff615ff7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6633d3e4f9d28039e8ecebb9ff615ff7">am_util_bootloader_check_index</a> (uint32_t index, uint32_t *pMask)</td></tr>
<tr class="memdesc:ga6633d3e4f9d28039e8ecebb9ff615ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check an index against a 32b mask value - used to implement a monotonic counter.  <br /></td></tr>
<tr class="separator:ga6633d3e4f9d28039e8ecebb9ff615ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1808021bd39c548095c3336838dc4183" id="r_ga1808021bd39c548095c3336838dc4183"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1808021bd39c548095c3336838dc4183">am_util_bootloader_erase_flash_page</a> (uint32_t ui32Addr)</td></tr>
<tr class="memdesc:ga1808021bd39c548095c3336838dc4183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a flash page.  <br /></td></tr>
<tr class="separator:ga1808021bd39c548095c3336838dc4183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac15c3e75e8c7df7d521723c80eca2839" id="r_gac15c3e75e8c7df7d521723c80eca2839"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac15c3e75e8c7df7d521723c80eca2839">am_util_bootloader_write_flash_within_page</a> (uint32_t ui32WriteAddr, uint32_t *pui32ReadAddr, uint32_t ui32NumWords)</td></tr>
<tr class="memdesc:gac15c3e75e8c7df7d521723c80eca2839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to flash area within a flash page.  <br /></td></tr>
<tr class="separator:gac15c3e75e8c7df7d521723c80eca2839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga817fe77346358e2bd670850dff8be278" id="r_ga817fe77346358e2bd670850dff8be278"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga817fe77346358e2bd670850dff8be278">am_util_bootloader_program_flash_page</a> (uint32_t ui32WriteAddr, uint32_t *pui32ReadAddr, uint32_t numBytes)</td></tr>
<tr class="memdesc:ga817fe77346358e2bd670850dff8be278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reprogram a flash page.  <br /></td></tr>
<tr class="separator:ga817fe77346358e2bd670850dff8be278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8056ade7032e6d46a798f57512431c30" id="r_ga8056ade7032e6d46a798f57512431c30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8056ade7032e6d46a798f57512431c30">am_util_bootloader_image_run</a> (<a class="el" href="structam__util__bootloader__image__t.html">am_util_bootloader_image_t</a> *psImage)</td></tr>
<tr class="memdesc:ga8056ade7032e6d46a798f57512431c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute an image that has already been written to flash.  <br /></td></tr>
<tr class="separator:ga8056ade7032e6d46a798f57512431c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gae25ba564f90bf20efdf87eba084ec484" name="gae25ba564f90bf20efdf87eba084ec484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae25ba564f90bf20efdf87eba084ec484">&#9670;&#160;</a></span>AM_BOOTLOADER_DISABLE_OVERRIDE_PIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AM_BOOTLOADER_DISABLE_OVERRIDE_PIN&#160;&#160;&#160;(0xFFFFFFFF)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga5564a2fd78f7d87200bcd88695a41c95" name="ga5564a2fd78f7d87200bcd88695a41c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5564a2fd78f7d87200bcd88695a41c95">&#9670;&#160;</a></span>AM_BOOTLOADER_OVERRIDE_HIGH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AM_BOOTLOADER_OVERRIDE_HIGH&#160;&#160;&#160;(0x1)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga25a37e846ff1306dcc9bc27f400e2741" name="ga25a37e846ff1306dcc9bc27f400e2741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25a37e846ff1306dcc9bc27f400e2741">&#9670;&#160;</a></span>AM_BOOTLOADER_OVERRIDE_LOW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AM_BOOTLOADER_OVERRIDE_LOW&#160;&#160;&#160;(0x0)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga32104fd66e8bf60867719c6b6c877b4b" name="ga32104fd66e8bf60867719c6b6c877b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32104fd66e8bf60867719c6b6c877b4b">&#9670;&#160;</a></span>CRC32_POLYNOMIAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRC32_POLYNOMIAL&#160;&#160;&#160;0x1EDC6F41</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga269dbb08c6c6e9ef5bb9e2e7b10e0986" name="ga269dbb08c6c6e9ef5bb9e2e7b10e0986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga269dbb08c6c6e9ef5bb9e2e7b10e0986">&#9670;&#160;</a></span>DPRINTF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DPRINTF</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga8c8f5274cc9c3fa31191bfd0eaec521d" name="ga8c8f5274cc9c3fa31191bfd0eaec521d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c8f5274cc9c3fa31191bfd0eaec521d">&#9670;&#160;</a></span>am_hal_bootloader_override_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool am_hal_bootloader_override_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structam__util__bootloader__image__t.html">am_util_bootloader_image_t</a> *</td>          <td class="paramname"><span class="paramname"><em>psImage</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the override GPIO for manual override. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psImage</td><td>- Pointer to the image structure.</td></tr>
  </table>
  </dd>
</dl>
<p>The image structure specifies a GPIO to manually override this test. If the GPIO state matches the state specified in the structure, this function returns false</p>
<dl class="section return"><dt>Returns</dt><dd>true if override is asserted </dd></dl>

</div>
</div>
<a id="ga6633d3e4f9d28039e8ecebb9ff615ff7" name="ga6633d3e4f9d28039e8ecebb9ff615ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6633d3e4f9d28039e8ecebb9ff615ff7">&#9670;&#160;</a></span>am_util_bootloader_check_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool am_util_bootloader_check_index </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>pMask</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check an index against a 32b mask value - used to implement a monotonic counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>is the index to be validated </td></tr>
    <tr><td class="paramname">pMask</td><td>is the pointer to the mask.</td></tr>
  </table>
  </dd>
</dl>
<p>This function can be used to validate an index against valid values The mask indicates the valid index values - up to 32 of them. MSB corresponds to index 0, bit 30 corresponds to index 1 and so on, LSB corresponds to index 31</p>
<dl class="section return"><dt>Returns</dt><dd>return false if the bit corresponding to index is set. </dd></dl>

</div>
</div>
<a id="gab072f2ea46afe90b7da77ccdd8500c16" name="gab072f2ea46afe90b7da77ccdd8500c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab072f2ea46afe90b7da77ccdd8500c16">&#9670;&#160;</a></span>am_util_bootloader_crc32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t am_util_bootloader_crc32 </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>pvData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>ui32NumBytes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CRC-32 implementation for the boot loader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pvData</td><td>- Pointer to the data to be checked. </td></tr>
    <tr><td class="paramname">ui32NumBytes</td><td>- Number of bytes to check.</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs a CRC-32 on the input data and returns the 32-bit result. This version does not use a table, so it has a smaller code footprint.</p>
<dl class="section return"><dt>Returns</dt><dd>32-bit CRC value. </dd></dl>

</div>
</div>
<a id="ga1808021bd39c548095c3336838dc4183" name="ga1808021bd39c548095c3336838dc4183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1808021bd39c548095c3336838dc4183">&#9670;&#160;</a></span>am_util_bootloader_erase_flash_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void am_util_bootloader_erase_flash_page </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>ui32Addr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase a flash page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Addr</td><td>is the starting address of flash page to be erased</td></tr>
  </table>
  </dd>
</dl>
<p>This function will erase the designated flash page Any existing data on the page will be erased even if number of bytes is less than page size</p>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="ga7a23f418618ff8d3423a51d17c6563a7" name="ga7a23f418618ff8d3423a51d17c6563a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a23f418618ff8d3423a51d17c6563a7">&#9670;&#160;</a></span>am_util_bootloader_fast_crc32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t am_util_bootloader_fast_crc32 </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>pvData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>ui32NumBytes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Faster CRC-32 implementation for the boot loader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pvData</td><td>- Pointer to the data to be checked. </td></tr>
    <tr><td class="paramname">ui32NumBytes</td><td>- Number of bytes to check.</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs a CRC-32 on the input data and returns the 32-bit result. This version uses a 256-entry lookup table to speed up the computation of the result.</p>
<dl class="section return"><dt>Returns</dt><dd>32-bit CRC value. </dd></dl>

</div>
</div>
<a id="ga43bd170339032395a3fecb6882241c73" name="ga43bd170339032395a3fecb6882241c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43bd170339032395a3fecb6882241c73">&#9670;&#160;</a></span>am_util_bootloader_flag_page_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int am_util_bootloader_flag_page_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structam__util__bootloader__image__t.html">am_util_bootloader_image_t</a> *</td>          <td class="paramname"><span class="paramname"><em>psImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>pui32FlagPage</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the bootloader flag page with a new image pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psImage</td><td>is a pointer to the image structure to use. </td></tr>
    <tr><td class="paramname">pui8FlagPage</td><td>is a pointer to the flag page address.</td></tr>
  </table>
  </dd>
</dl>
<p>This function also computes and updates the checksum of the image info. This function will overwrite the existing flag page entry with a new reference to the image described by psImage.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gac905290d5b802192e17b3ec13eaa7b2f" name="gac905290d5b802192e17b3ec13eaa7b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac905290d5b802192e17b3ec13eaa7b2f">&#9670;&#160;</a></span>am_util_bootloader_flash_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool am_util_bootloader_flash_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structam__util__bootloader__image__t.html">am_util_bootloader_image_t</a> *</td>          <td class="paramname"><span class="paramname"><em>psImage</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the flash contents of a boot image to make sure it's safe to run. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psImage</td><td>- Pointer to the image structure.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to determine whether the flash contents of a boot image is safe to run.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the image is safe to run. </dd></dl>

</div>
</div>
<a id="gaea8a729bf77564c20ca7ec3ac40c7a0c" name="gaea8a729bf77564c20ca7ec3ac40c7a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea8a729bf77564c20ca7ec3ac40c7a0c">&#9670;&#160;</a></span>am_util_bootloader_image_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool am_util_bootloader_image_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structam__util__bootloader__image__t.html">am_util_bootloader_image_t</a> *</td>          <td class="paramname"><span class="paramname"><em>psImage</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a boot image to make sure it's safe to run. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psImage</td><td>- Pointer to the image structure.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to determine whether a boot image is safe to run. It verifies that the starting stack-pointer and reset vector entries for the new image are reasonable. If these tests pass, it also runs a CRC-32 on the image and checks the result against the expected CRC-32 value from the image structure.</p>
<p>The image structure can also specify a GPIO to manually override this test. If the GPIO state matches the state specified in the structure, this test will mark the image as "unsafe" regardless of the other conditions.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the image is safe to run. </dd></dl>

</div>
</div>
<a id="ga8056ade7032e6d46a798f57512431c30" name="ga8056ade7032e6d46a798f57512431c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8056ade7032e6d46a798f57512431c30">&#9670;&#160;</a></span>am_util_bootloader_image_run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void am_util_bootloader_image_run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structam__util__bootloader__image__t.html">am_util_bootloader_image_t</a> *</td>          <td class="paramname"><span class="paramname"><em>psImage</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute an image that has already been written to flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psImage</td><td>is a pointer to the image structure.</td></tr>
  </table>
  </dd>
</dl>
<p>This function can be used to "run" a program that has already been downloaded and written to flash. It does this by reading the initial stack-pointer and reset vector information from the image written in flash, writing that information to the relevant registers, and immediately branching to the new reset vector location.</p>
<p>Note that this method does not include any type of reset. It is the callers responsibility to ensure that the MCU is in a valid state for the subsequent program to run. One way to guarantee this is to run this function very early after a RESET event, before clocks or peripherals are configured.</p>
<dl class="section return"><dt>Returns</dt><dd>The function does not return. </dd></dl>

</div>
</div>
<a id="ga74d3f2365b98ae51cb42976a79676f1b" name="ga74d3f2365b98ae51cb42976a79676f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74d3f2365b98ae51cb42976a79676f1b">&#9670;&#160;</a></span>am_util_bootloader_partial_crc32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void am_util_bootloader_partial_crc32 </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>pvData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>ui32NumBytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>pui32CRC</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CRC-32 implementation allowing multiple partial images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pvData</td><td>- Pointer to the data to be checked. </td></tr>
    <tr><td class="paramname">ui32NumBytes</td><td>- Number of bytes to check. </td></tr>
    <tr><td class="paramname">pui32CRC</td><td>- Location to store the partial CRC32 result.</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs a CRC-32 on the input data and returns the 32-bit result. This version uses a 256-entry lookup table to speed up the computation of the result. The result of the CRC32 is stored in the location given by the caller. This allows the caller to keep a "running" CRC for individual chunks of an image.</p>
<dl class="section return"><dt>Returns</dt><dd>32-bit CRC value. </dd></dl>

</div>
</div>
<a id="ga817fe77346358e2bd670850dff8be278" name="ga817fe77346358e2bd670850dff8be278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga817fe77346358e2bd670850dff8be278">&#9670;&#160;</a></span>am_util_bootloader_program_flash_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void am_util_bootloader_program_flash_page </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>ui32WriteAddr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>pui32ReadAddr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>numBytes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reprogram a flash page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32WriteAddr</td><td>is the starting address of flash page to be programmed </td></tr>
    <tr><td class="paramname">pui32ReadAddr</td><td>is the pointer to data to be programmed </td></tr>
    <tr><td class="paramname">numBytes</td><td>is the number of bytes to be programmed</td></tr>
  </table>
  </dd>
</dl>
<p>This function will re-program the designated flash page by erasing &amp; then writing new data. Any existing data will be overwritten even if number of bytes is less than page size</p>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="ga3a3b3b78fef9c0df8deab63550c79a9e" name="ga3a3b3b78fef9c0df8deab63550c79a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a3b3b78fef9c0df8deab63550c79a9e">&#9670;&#160;</a></span>am_util_bootloader_validate_structure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool am_util_bootloader_validate_structure </td>
          <td>(</td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>pInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates a information structure integrity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pInfo</td><td>is a pointer to the information structure </td></tr>
    <tr><td class="paramname">size</td><td>is the size of the structure</td></tr>
  </table>
  </dd>
</dl>
<p>This function will compute the CRC for the information structure and validate it against the contents in the last 4 bytes of the same. It assumes that the structure contains the CRC-32 of the information in the last 4 bytes of the structure</p>
<dl class="section return"><dt>Returns</dt><dd>true if the check passes. </dd></dl>

</div>
</div>
<a id="gac15c3e75e8c7df7d521723c80eca2839" name="gac15c3e75e8c7df7d521723c80eca2839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac15c3e75e8c7df7d521723c80eca2839">&#9670;&#160;</a></span>am_util_bootloader_write_flash_within_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void am_util_bootloader_write_flash_within_page </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>ui32WriteAddr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>pui32ReadAddr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>ui32NumWords</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to flash area within a flash page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32WriteAddr</td><td>is the starting address of flash to be programmed </td></tr>
    <tr><td class="paramname">pui32ReadAddr</td><td>is the pointer to data to be programmed </td></tr>
    <tr><td class="paramname">numBytes</td><td>is the number of bytes to be programmed</td></tr>
  </table>
  </dd>
</dl>
<p>This function will write to the designated flash area. This function does not erase the page, and hence if it has not been erased earlier, it will effectively AND the new data to existing flash content.</p>
<p>All the write should be within a flash page. It does not affect rest of the flash page.</p>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1">
    <body>
        <div id="footer" align="right">        
            <small>
                Generated on Thu Oct 30 2025 19:27:25 for the AmbiqSuite User Guide by&nbsp;
                <a href="http://www.ambiqmicro.com">
                <img class="footer" src="./ambiq_logo.png" alt="Ambiq"/></a>&nbsp&nbsp Copyright &copy; 2025&nbsp&nbsp<br />
                This documentation is licensed and distributed under the <a rel="license" href="http://opensource.org/licenses/BSD-3-Clause">BSD 3-Clause License</a>.&nbsp&nbsp<br/>
            </small>
        </div>
    </body>
</html>
