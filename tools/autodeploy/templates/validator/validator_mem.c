/******************************************************************************
 * @file        validator_mem.c
 * @brief       Autogenerated validator memory
 * @details     This file is generated by the validator.py script.
 *   This file represents the memory functions for the validator.
 *
 * @date        2025-08-21
 *
 * @copyright
 *   © 2025 Ambiq. All rights reserved.
 *
 *   This generated C module is licensed for use **only** on Ambiq hardware
 *   incorporating Ambiq’s sub-threshold power optimized technology.
 *   Any other use is strictly prohibited.
 * *
 * @note        Do not edit this file—any changes will be overwritten.
 ******************************************************************************/
#include <stdint.h>
#include <string.h>

#include "validator_mem.h"
#include "mut_model_metadata.h"   // buffer sizes & locations

// Generated model data when not streaming via PSRAM
#if (TFLM_MODEL_LOCATION != NS_AD_PSRAM) && (NS_AD_AOT == 0)
#include "mut_model_data.h"
#endif

// TX/RX sizes from metadata
#ifndef NS_OUTPUT_TENSOR_BUFFER_SIZE
  #if defined(AM_PART_APOLLO5B)
    #define NS_OUTPUT_TENSOR_BUFFER_SIZE 200000u
  #elif defined(AM_PART_APOLLO3) || defined(AM_PART_APOLLO3P)
    #define NS_OUTPUT_TENSOR_BUFFER_SIZE 20000u
  #else
    #define NS_OUTPUT_TENSOR_BUFFER_SIZE 50000u
  #endif
#endif

// ------------------------- Scratch / hold buffers ----------------------------
static NS_SRAM_BSS uint8_t s_tx_scratch[TFLM_VALIDATOR_TX_BUFSIZE] __attribute__((aligned(4)));
static NS_SRAM_BSS uint8_t s_out_hold [NS_OUTPUT_TENSOR_BUFFER_SIZE] __attribute__((aligned(4)));

uint8_t* vrpc_tx_scratch(void){ return s_tx_scratch; }
uint32_t vrpc_tx_scratch_size(void){ return (uint32_t)sizeof(s_tx_scratch); }
uint8_t* vrpc_out_hold_buf(void){ return s_out_hold; }

// ---------------------- Model pointer and arena pointer ----------------------
#if (TFLM_MODEL_LOCATION == NS_AD_PSRAM)
static uint8_t* s_model_ptr = 0;   // set at runtime once PSRAM is ready
// #else
// extern const unsigned char mut_model[]; // from mut_model_data.h when not PSRAM
#endif

#if (TFLM_ARENA_LOCATION == NS_AD_PSRAM)
static uint8_t* s_arena_ptr = 0;   // set at runtime after PSRAM base known
static const uint32_t s_arena_size = 10u * 1024u * 1024u; // 10 MB, matches template
#elif (TFLM_ARENA_LOCATION == NS_AD_SRAM)
NS_SRAM_BSS __attribute__((aligned(16))) static uint8_t s_arena[TFLM_VALIDATOR_ARENA_SIZE * 1024u];
static uint8_t* s_arena_ptr = s_arena;
static const uint32_t s_arena_size = (uint32_t)sizeof(s_arena);
#else // TCM
NS_PUT_IN_TCM __attribute__((aligned(16))) static uint8_t s_arena[TFLM_VALIDATOR_ARENA_SIZE * 1024u];
static uint8_t* s_arena_ptr = s_arena;
static const uint32_t s_arena_size = (uint32_t)sizeof(s_arena);
#endif

void ns_mem_init_defaults(void){
#if (TFLM_MODEL_LOCATION == NS_AD_PSRAM)
  s_model_ptr = 0;  // must be set via ns_mem_set_psram_base()
#endif
#if (TFLM_ARENA_LOCATION == NS_AD_PSRAM)
  s_arena_ptr = 0;  // will be base + offset in app layer; we keep base here
#endif
}

void ns_mem_set_psram_base(uint8_t* base){
#if (TFLM_MODEL_LOCATION == NS_AD_PSRAM)
  s_model_ptr = base;
#endif
#if (TFLM_ARENA_LOCATION == NS_AD_PSRAM)
  // leave 20MB for model as in template; arena starts at +20MB
  s_arena_ptr = base + (20u * 1024u * 1024u);
#endif
}

#if NS_AD_AOT == 0
uint8_t* ns_mem_model_ptr(void){
#if (TFLM_MODEL_LOCATION == NS_AD_PSRAM)
  return s_model_ptr;
#else
  return (uint8_t*)mut_model;  // const ok for reads; firmware places correctly
#endif
}
#endif

uint8_t* ns_mem_arena_ptr(void){ return s_arena_ptr; }
uint32_t ns_mem_arena_size(void){ return s_arena_size; }

// Allow host to stream model chunks into PSRAM-backed model buffer
int vrpc_model_write(uint32_t offset, const void* data, uint32_t len){
#if (TFLM_MODEL_LOCATION == NS_AD_PSRAM)
  if (!s_model_ptr) return -1;
  memcpy(s_model_ptr + offset, data, len);
  return 0;
#else
  (void)offset; (void)data; (void)len; return -1; // not supported
#endif
}