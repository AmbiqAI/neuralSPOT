// ICM45605 driver for NeuralSpot IMU

#include "ns_imu.h"
#include "ICM45605.h"

ns_spi_config_t static ns_imu_spi_config; // for isr
#define NS_IMU_ICM45605_MAX_RETRIES 50

void static ns_imu_ICM45605_enable(uint8_t port)
{
  // AP510 Mikroe Board is SPI0
  #ifdef AM_PART_APOLLO5B
  if (port != 0) {
    ns_lp_printf("ICM45605: SPI port must be 0 for AP510 EVB, %d not supported\n", port);
    return;
  }
  // Configure and init SPI0
  ns_imu_spi_config.iom = port;
  ns_spi_interface_init(&ns_imu_spi_config, AM_HAL_IOM_8MHZ, AM_HAL_IOM_SPI_MODE_3);

  ns_delay_us(8000);
}

// ICM45605 interface disable
void static ns_imu_ICM45605_disable(void)
{
  // not implemented yet
}

// ICM45605 command_write
uint32_t static ns_imu_ICM45605_data_write(uint8_t address,const uint8_t *data,uint32_t length)
{
  return ns_spi_write(&ns_imu_spi_config, data, length, address, 1, 0);
}

// ICM45605 command_read
int8_t static ns_imu_ICM45605_data_read(uint8_t address, uint8_t *buff,uint32_t length)
{
  return ns_spi_read(&ns_imu_spi_config, buff, length, address, 1, 0);
}

uint32_t ns_imu_ICM45605_init(uint8_t port)
{
  uint8_t found = 0;
  uint8_t buff[2] = { 0 };

  ns_imu_ICM45605_enable(port);

  for (uint8_t i = 0; i<NS_IMU_ICM45605_MAX_RETRIES; i++) {   // Repeat Call until we get the correct response
      if (NS_STATUS_SUCCESS != ns_imu_ICM45605_data_read(ICM45605_REG_WHO_AM_I, buff, 1)) {
        ns_lp_printf("ICM45605: Read failed\n");
        return NS_STATUS_FAILURE;
      }
      if (buff[0] == 0xe5){
        found = 1;
        break;  // Break when communication is good.
      }
  }
  if (found == 0) {
    ns_lp_printf("ICM45605: No response after %d retries\n", NS_IMU_ICM45605_MAX_RETRIES);
    return NS_STATUS_FAILURE;
  }

  buff[0] = 0x0F;
  ns_imu_ICM45605_data_write(ICM45605_REG_PWR_MGMNT0, buff, 1);
  buff[0] = 0x47;
  ns_imu_ICM45605_data_write(ICM45605_REG_ACCEL_CONFIG0, buff, 1);
  buff[0] = 0x47;
  ns_imu_ICM45605_data_write(ICM45605_REG_GYRO_CONFIG0, buff, 1);
  return NS_STATUS_SUCCESS;
}

uint32_t ns_imu_ICM45605_get_accel_gyro(uint8_t *buff)
{
  uint8_t valid = 0;

  for (uint8_t j = 0; j<NS_IMU_ICM45605_MAX_RETRIES; j++) {
    for (uint8_t i = 0; i<12; i++) {
        uint32_t ret = ns_imu_ICM45605_data_read(ICM45605_REG_ACCEL_DATA_X1_UI+i, &buff[i], 1);
        if (ret != NS_STATUS_SUCCESS) {
          //ns_lp_printf("ICM45605: Read failed\n");
          return NS_STATUS_FAILURE;
        }
    }
    if ((buff[0] == 0) && (buff[1] == 0) &&
        (buff[2] == 0) && (buff[3] == 0) &&
        (buff[4] == 0) && (buff[5] == 0) )
      {
        continue;
      } else {
        valid = 1;
        break;
      }
  }
  if (valid == 0) {
    //ns_lp_printf("ICM45605: No data after %d retries\n", NS_IMU_ICM45605_MAX_RETRIES);
    return NS_STATUS_FAILURE;
  }
  // ICM45605_disable();
  return NS_STATUS_SUCCESS;
}

