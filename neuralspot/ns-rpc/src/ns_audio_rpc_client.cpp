// @file ns-audio-rpc.erpc
//!
//! @brief Interface definition for neuralspot audio RPC
//!
//!

/*
 * Generated by erpcgen 1.9.1 on Thu Aug 25 16:32:36 2022.
 *
 * AUTOGENERATED - DO NOT EDIT
 */


#include "erpc_client_manager.h"
#if ERPC_ALLOCATION_POLICY == ERPC_ALLOCATION_POLICY_DYNAMIC
#include "erpc_port.h"
#endif
#include "erpc_codec.hpp"
extern "C"
{
#include "ns_audio_rpc.h"
}

#if 10901 != ERPC_VERSION_NUMBER
#error "The generated shim code version is different to the rest of eRPC code."
#endif

using namespace erpc;
using namespace std;

extern ClientManager *g_client;


// Constant variable definitions
#pragma weak max_audio_buffer_length
extern const int32_t max_audio_buffer_length = 1024;

//! @brief Function to write struct nsAudioBuffer_t
static void write_nsAudioBuffer_t_struct(erpc::Codec * codec, const nsAudioBuffer_t * data);

//! @brief Function to write struct audioCommand_t
static void write_audioCommand_t_struct(erpc::Codec * codec, const audioCommand_t * data);


// Write struct nsAudioBuffer_t function implementation
static void write_nsAudioBuffer_t_struct(erpc::Codec * codec, const nsAudioBuffer_t * data)
{
    if(NULL == data)
    {
        return;
    }

    codec->write(data->bufferLength);

    codec->writeBinary(1024, data->buf);
}

// Write struct audioCommand_t function implementation
static void write_audioCommand_t_struct(erpc::Codec * codec, const audioCommand_t * data)
{
    if(NULL == data)
    {
        return;
    }

    codec->write(static_cast<int32_t>(data->cmd));

    write_nsAudioBuffer_t_struct(codec, &(data->buf));
}



// ns_audio_rpc interface erpcDumpAudioBuffer function client shim.
nsAudioStatus_e erpcDumpAudioBuffer(const audioCommand_t * buf)
{
    erpc_status_t err = kErpcStatus_Success;

    nsAudioStatus_e result;

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = g_client->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kns_audio_rpc_service_id, kns_audio_rpc_erpcDumpAudioBuffer_id, request.getSequence());

        write_audioCommand_t_struct(codec, buf);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<nsAudioStatus_e>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kns_audio_rpc_erpcDumpAudioBuffer_id);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = g_client->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    if (err != kErpcStatus_Success)
    {
        result = (nsAudioStatus_e) -1;
    }

    return result;
}
