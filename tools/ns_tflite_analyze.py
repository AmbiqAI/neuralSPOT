#!/usr/bin/env python
import os
import sys
from pathlib import Path

from utils.tflite_helpers import (
    CreateAddFromSnakeOpName,
    CreateDictFromFlatbuffer,
    OpCodeMapper,
    TensorAnalyze,
)


def analyze_tflite_file(tflite_file, model_name=""):  # pylint: disable=invalid-name
    with open(tflite_file, "rb") as file_handle:
        file_data = bytearray(file_handle.read())

    if model_name == "":
        model_name = Path(tflite_file).stem

    data = CreateDictFromFlatbuffer(file_data)
    count = 0

    # Initialize Return values
    overall_ops_names_list = []
    overall_mac_estimate_list = []
    opset = []
    code = f"// Autogenerated TFLite Per-Layer Estimated MAC counts, autogenerated by {Path(__file__).stem}\n"
    code += f"uint32_t {model_name}_mac_estimates[] = {{"
    subgraph_length = 0

    # Update builtin code fields.
    for d in data["operator_codes"]:
        d["builtin_code"] = max(d["builtin_code"], d["deprecated_builtin_code"])

    for subgraph_idx, g in enumerate(data["subgraphs"]):
        ops_names_list = []
        mac_estimate_list = []

        ta = TensorAnalyze(g)
        op_to_str = OpCodeMapper(data)

        if subgraph_idx > 0:  # only subgraph 0 supported TODO add multi-graph support
            subgraph_length = len(g["operators"])
        else:
            opset.append(op_to_str.code_to_name)  # only subgraph0

        # print(subgraph_idx)
        # print(g["operators"])

        if g["operators"]:
            for idx, tensor in enumerate(g["operators"]):

                opcodeName = op_to_str(tensor["opcode_index"])
                if opcodeName in ["CONV_2D", "DEPTHWISE_CONV_2D", "FULLY_CONNECTED"]:
                    inputs = ta([tensor["inputs"][0]])
                    outputs = ta([tensor["outputs"][0]])
                # print(tensor)
                # print(opcodeName)

                if opcodeName == "CONV_2D":
                    # Conv2D
                    """
                    output_channels = filter->dims->data[0];
                    filter_width = filter->dims->data[1];
                    filter_height = filter->dims->data[2];
                    input_channels = filter->dims->data[3];
                    output_width = output->dims->data[1];
                    output_height = output->dims->data[2];
                    """
                    # filter_width * filter_height * output_width * output_height * input_channels * output_channels
                    filter = ta([tensor["inputs"][1]])
                    macs = (
                        filter["shape"][1]
                        * filter["shape"][2]
                        * outputs["shape"][1]
                        * outputs["shape"][2]
                        * filter["shape"][0]
                        * inputs["shape"][3]
                    )
                elif opcodeName == "DEPTHWISE_CONV_2D":
                    """
                    filter_width = filter->dims->data[1];
                    filter_height = filter->dims->data[2];
                    channels = filter->dims->data[3];
                    output_width = output->dims->data[1];
                    output_height = output->dims->data[2];
                    """
                    # filter_width * filter_height * output_width * output_height * channels
                    filter = ta([tensor["inputs"][1]])
                    macs = (
                        filter["shape"][1]
                        * filter["shape"][2]
                        * outputs["shape"][1]
                        * outputs["shape"][2]
                        * filter["shape"][3]
                    )
                elif opcodeName == "FULLY_CONNECTED":
                    """
                    num_batches = output_shape.Dims(0);
                    output_depth = output_shape.Dims(1);
                    accum_depth = filter_shape.Dims(-1);
                    macs = accum_depth * output_depth * batch_size
                    """
                    filter = ta([tensor["inputs"][1]])
                    macs = (
                        filter["shape"][-1] * outputs["shape"][0] * outputs["shape"][1]
                    )
                else:
                    macs = 0

                ops_names_list.append(opcodeName)
                mac_estimate_list.append(macs)

                if subgraph_idx == 0:
                    code = code + repr(macs) + ", "
                    count = count + 1
            overall_ops_names_list.append(ops_names_list)
            overall_mac_estimate_list.append(mac_estimate_list)

        if subgraph_idx == 0:
            code = code + "};\n\n"
            code = (
                code
                + "const int "
                + model_name
                + "_number_of_estimates = "
                + repr(count)
                + ";"
            )
    return (
        code,
        overall_ops_names_list,
        overall_mac_estimate_list,
        opset,
        len(data["subgraphs"]),
    )


def main(argv):
    try:
        tflite_input = argv[1]
    except IndexError:
        print("Usage: %s <input tflite>" % (argv[0]))
    else:
        code, ops, macs, opset, slen = analyze_tflite_file(tflite_input)

        print(opset[0])

        for i, opname in opset[0].items():
            CreateAddFromSnakeOpName(opname)

        print(code)
        print(ops)
        print(str(macs).replace("[", "").replace("]", ""))
        print(macs)
        print(slen)


if __name__ == "__main__":
    main(sys.argv)
