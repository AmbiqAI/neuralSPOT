/*
 * Generated by erpcgen 1.9.1 on Fri Sep  9 09:53:34 2022.
 *
 * AUTOGENERATED - DO NOT EDIT
 */


#include "erpc_client_manager.h"
#include "erpc_port.h"
#include "erpc_codec.hpp"
extern "C"
{
#include "GenericDataOperations_PcToEvb.h"
// import callbacks declaration from other groups
#include "GenericDataOperations_EvbToPc.h"
}

#if 10901 != ERPC_VERSION_NUMBER
#error "The generated shim code version is different to the rest of eRPC code."
#endif

using namespace erpc;
using namespace std;

extern ClientManager *g_client;

//! @brief Function to write struct dataBlock
static void write_dataBlock_struct(erpc::Codec * codec, const dataBlock * data);

//! @brief Function to write struct binary_t
static void write_binary_t_struct(erpc::Codec * codec, const binary_t * data);


// Write struct dataBlock function implementation
static void write_dataBlock_struct(erpc::Codec * codec, const dataBlock * data)
{
    if(NULL == data)
    {
        return;
    }

    codec->write(data->length);

    codec->write(static_cast<int32_t>(data->dType));

    codec->writeString(strlen((const char*)data->description), (const char*)data->description);

    codec->write(static_cast<int32_t>(data->cmd));

    write_binary_t_struct(codec, &(data->buffer));
}

// Write struct binary_t function implementation
static void write_binary_t_struct(erpc::Codec * codec, const binary_t * data)
{
    if(NULL == data)
    {
        return;
    }

    codec->writeBinary(data->dataLength, data->data);
}


//! @brief Function to read struct dataBlock
static void read_dataBlock_struct(erpc::Codec * codec, dataBlock * data);

//! @brief Function to read struct binary_t
static void read_binary_t_struct(erpc::Codec * codec, binary_t * data);


// Read struct dataBlock function implementation
static void read_dataBlock_struct(erpc::Codec * codec, dataBlock * data)
{
    int32_t _tmp_local;

    if(NULL == data)
    {
        return;
    }

    codec->read(&data->length);

    codec->read(&_tmp_local);
    data->dType = static_cast<dataType>(_tmp_local);

    uint32_t description_len;
    char * description_local;
    codec->readString(&description_len, &description_local);
    data->description = (char*) erpc_malloc((description_len + 1) * sizeof(char));
    if ((data->description == NULL) || (description_local == NULL))
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(data->description, description_local, description_len);
        (data->description)[description_len] = 0;
    }

    codec->read(&_tmp_local);
    data->cmd = static_cast<command>(_tmp_local);

    read_binary_t_struct(codec, &(data->buffer));
}

// Read struct binary_t function implementation
static void read_binary_t_struct(erpc::Codec * codec, binary_t * data)
{
    if(NULL == data)
    {
        return;
    }

    uint8_t * data_local;
    codec->readBinary(&data->dataLength, &data_local);
    data->data = (uint8_t *) erpc_malloc(data->dataLength * sizeof(uint8_t));
    if ((data->data == NULL) && (data->dataLength > 0))
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(data->data, data_local, data->dataLength);
    }
}



// pc_to_evb interface ns_rpc_data_sendBlockToEVB function client shim.
status ns_rpc_data_sendBlockToEVB(const dataBlock * block)
{
    erpc_status_t err = kErpcStatus_Success;

    status result;

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = g_client->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kpc_to_evb_service_id, kpc_to_evb_ns_rpc_data_sendBlockToEVB_id, request.getSequence());

        write_dataBlock_struct(codec, block);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        codec->read(&_tmp_local);
        result = static_cast<status>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kpc_to_evb_ns_rpc_data_sendBlockToEVB_id);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = g_client->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    if (err != kErpcStatus_Success)
    {
        result = (status) -1;
    }

    return result;
}

// pc_to_evb interface ns_rpc_data_fetchBlockFromEVB function client shim.
status ns_rpc_data_fetchBlockFromEVB(dataBlock * block)
{
    erpc_status_t err = kErpcStatus_Success;

    status result;

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = g_client->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kpc_to_evb_service_id, kpc_to_evb_ns_rpc_data_fetchBlockFromEVB_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        read_dataBlock_struct(codec, block);

        codec->read(&_tmp_local);
        result = static_cast<status>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kpc_to_evb_ns_rpc_data_fetchBlockFromEVB_id);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = g_client->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    if (err != kErpcStatus_Success)
    {
        result = (status) -1;
    }

    return result;
}

// pc_to_evb interface ns_rpc_data_computeOnEVB function client shim.
status ns_rpc_data_computeOnEVB(const dataBlock * in_block, dataBlock * result_block)
{
    erpc_status_t err = kErpcStatus_Success;

    status result;

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = g_client->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kpc_to_evb_service_id, kpc_to_evb_ns_rpc_data_computeOnEVB_id, request.getSequence());

        write_dataBlock_struct(codec, in_block);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        int32_t _tmp_local;

        read_dataBlock_struct(codec, result_block);

        codec->read(&_tmp_local);
        result = static_cast<status>(_tmp_local);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kpc_to_evb_ns_rpc_data_computeOnEVB_id);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = g_client->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    if (err != kErpcStatus_Success)
    {
        result = (status) -1;
    }

    return result;
}
