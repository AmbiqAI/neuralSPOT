/******************************************************************************
 * @file        validator_chunk.h
 * @brief       Autogenerated validator chunk
 * @details     This file is generated by the validator.py script.
 *   This file represents the chunking functions for the validator.
 *
 * @date        2025-08-21
 *
 * @copyright
 *   © 2025 Ambiq. All rights reserved.
 *
 *   This generated C module is licensed for use **only** on Ambiq hardware
 *   incorporating Ambiq’s sub-threshold power optimized technology.
 *   Any other use is strictly prohibited.
 * *
 * @note        Do not edit this file—any changes will be overwritten.
 ******************************************************************************/
#pragma once
#include <stdint.h>
#include <stdbool.h>
#include "tflm_validator.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
  uint32_t total;        // total payload bytes
  uint32_t progressed;   // bytes sent/received so far
  uint32_t max_chunk;    // max payload per chunk (bytes)
  bool     active;       // whether chunking is in progress
} ns_chunk_t;

static inline void ns_chunk_reset(ns_chunk_t* c){ c->total=0; c->progressed=0; c->max_chunk=0; c->active=false; }

static inline void ns_chunk_begin(ns_chunk_t* c, uint32_t total, uint32_t max_chunk){
  ns_lp_printf("ns_chunk_begin total %d, max_chunk %d\n", total, max_chunk);
  c->total = total; c->progressed = 0; c->max_chunk = max_chunk; c->active = (total > max_chunk);
  ns_lp_printf("c->active %d\n", c->active);
}

static inline uint32_t ns_chunk_remaining(const ns_chunk_t* c){
//   ns_lp_printf("ns_chunk_remaining total %d, progressed %d\n", c->total, c->progressed);
  return (c->total > c->progressed) ? (c->total - c->progressed) : 0u;
}

static inline uint32_t ns_chunk_next(const ns_chunk_t* c){
//   ns_lp_printf("ns_chunk_next total %d, max_chunk %d\n", c->total, c->max_chunk);
  uint32_t rem = ns_chunk_remaining(c);
  return (rem > c->max_chunk) ? c->max_chunk : rem;
}

static inline void ns_chunk_advance(ns_chunk_t* c, uint32_t n){
//   ns_lp_printf("ns_chunk_advance total %d, progressed %d, n %d\n", c->total, c->progressed, n);
  if (c->active) {
    c->progressed += n;
  }
//   if (c->progressed >= c->total) { c->progressed = c->total; c->active = false; }
}

static inline bool ns_chunk_done(ns_chunk_t* c){ 
    ns_lp_printf("ns_chunk_done total %d, progressed %d\n", c->total, c->progressed);
    if (c->progressed >= c->total) { c->progressed = c->total; c->active = false; }

    return ns_chunk_remaining(c) == 0u;
}

#ifdef __cplusplus
}  // extern "C"
#endif