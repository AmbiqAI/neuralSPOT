--- LOCAL:rtos.c
+++ MERGED:rtos.c
@@ -43,26 +43,30 @@
 // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 // POSSIBILITY OF SUCH DAMAGE.
 //
+<<<<<<< LOCAL
 // This is part of revision release_sdk_4_1_0-8020bdf229 of the AmbiqSuite
-// Development Package.
-//
-//*****************************************************************************
-
-#include <stdbool.h>
+=======
+// This is part of revision release_sdk5_2_a_1_1-c2486c8ef of the AmbiqSuite Development Package.
+>>>>>>> REMOTE
+//
+//*****************************************************************************
+
 #include <stdint.h>
 
-#include "am_bsp.h"
+
 #include "am_mcu_apollo.h"
 
+
 #include "FreeRTOS.h"
-#include "portable.h"
-#include "portmacro.h"
-#include "queue.h"
 #include "task.h"
 
 //*****************************************************************************
 //
 // Task handle for the initial setup task.
+
+//*****************************************************************************
+//
+// Task handle for the initial setup task.
 //
 //*****************************************************************************
 TaskHandle_t xSetupTask;
@@ -74,6 +78,7 @@
 //*****************************************************************************
 void
 am_timer_isr(void) {
+    uint32_t ui32Status;
     uint32_t ui32Status;
 
     am_hal_timer_interrupt_status_get(false, &ui32Status);
@@ -98,10 +103,20 @@
 }
 
 //*****************************************************************************
+    am_hal_sysctrl_sleep(AM_HAL_SYSCTRL_SLEEP_DEEP);
+    return 0;
+}
+
+//*****************************************************************************
+//
+// Recovery function called from FreeRTOS IDLE task, after waking up from Sleep
+    return 0;
+}
+
+//*****************************************************************************
 //
 // Recovery function called from FreeRTOS IDLE task, after waking up from Sleep
 // Do necessary 'wakeup' operations here, e.g. to power up/enable peripherals
-// etc.
 //
 //*****************************************************************************
 void
@@ -116,6 +131,7 @@
 //*****************************************************************************
 void
 vApplicationMallocFailedHook(void) {
+    //
     //
     // Called if a call to pvPortMalloc() fails because there is insufficient
     // free memory available in the FreeRTOS heap.  pvPortMalloc() is called
@@ -124,7 +140,6 @@
     // configTOTAL_HEAP_SIZE configuration constant in FreeRTOSConfig.h.
     //
     while (1)
-        ;
 }
 
 void
@@ -139,6 +154,7 @@
     //
     while (1) {
         __asm("BKPT #0\n"); // Break into the debugger
+    }
     }
 }
 
@@ -154,10 +170,16 @@
      * the stack and so not exists after this function exits. */
     static StaticTask_t xIdleTaskTCB;
     static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];
+{
+    /* If the buffers to be provided to the Idle task are declared inside this
+     * function then they must be declared static - otherwise they will be allocated on
+     * the stack and so not exists after this function exits. */
+    static StaticTask_t xIdleTaskTCB;
 
     /* Pass out a pointer to the StaticTask_t structure in which the Idle
      * task's state will be stored. */
     *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
+
 
     /* Pass out the array that will be used as the Idle task's stack. */
     *ppxIdleTaskStackBuffer = uxIdleTaskStack;
@@ -166,6 +188,9 @@
      * Note that, as the array is necessarily of type StackType_t,
      * configMINIMAL_STACK_SIZE is specified in words, not bytes. */
     *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
+}
+
+    /* Pass out the size of the array pointed to by *ppxIdleTaskStackBuffer.
 }
 
 /* configUSE_STATIC_ALLOCATION and configUSE_TIMERS are both set to 1, so the
@@ -175,21 +200,22 @@
                                      StackType_t ** ppxTimerTaskStackBuffer,
                                      uint32_t * pulTimerTaskStackSize )
 {
+{
     /* If the buffers to be provided to the Timer task are declared inside this
      * function then they must be declared static - otherwise they will be allocated on
      * the stack and so not exists after this function exits. */
     static StaticTask_t xTimerTaskTCB;
     static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];
 
+
     /* Pass out a pointer to the StaticTask_t structure in which the Timer
      * task's state will be stored. */
     *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
 
+
     /* Pass out the array that will be used as the Timer task's stack. */
     *ppxTimerTaskStackBuffer = uxTimerTaskStack;
 
     /* Pass out the size of the array pointed to by *ppxTimerTaskStackBuffer.
      * Note that, as the array is necessarily of type StackType_t,
-     * configTIMER_TASK_STACK_DEPTH is specified in words, not bytes. */
-    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
-}+
