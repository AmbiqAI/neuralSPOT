/******************************************************************************
 * @file        aot_validator_main.c
 * @brief       Autogenerated AOT validator main
 * @details     This file is generated by the validator.py script.
 *   This file represents the main entry point for the AOT validator.
 *
 * @date        2025-08-21
 *
 * @copyright
 *   © 2025 Ambiq. All rights reserved.
 *
 *   This generated C module is licensed for use **only** on Ambiq hardware
 *   incorporating Ambiq’s sub-threshold power optimized technology.
 *   Any other use is strictly prohibited.
 * *
 * @note        Do not edit this file—any changes will be overwritten.
 ******************************************************************************/
#include <stdint.h>
#include <string.h>

#include "ns_ambiqsuite_harness.h"
#include "ns_core.h"
#include "ns_peripherals_power.h"
#include "ns_rpc_generic_data.h"
#include "ns_debug_log.h"

#include "tflm_validator.h"              // ns_incoming_config_t / ns_outgoing_stats_t
#include "mut_model_metadata.h"          // buffer sizes & locations, NS_AD_AOT
#include "validator_mem.h"               // scratch + model/arena helpers

// RPC handlers implemented in validator_rpc.c
status decodeIncomingSendblock(const dataBlock *in);
status decodeIncomingFetchblock(dataBlock *ret);
status infer(const dataBlock *in, dataBlock *res);

// ------------------------- Globals required by RPC --------------------------
NS_SRAM_BSS ns_incoming_config_t mut_cfg;
NS_SRAM_BSS ns_outgoing_stats_t  mut_stats;

// Application-allocated RPC FIFOs
NS_SRAM_BSS uint8_t aot_v_cdc_rx_ff_buf[TFLM_VALIDATOR_RX_BUFSIZE] __attribute__((aligned(4)));
NS_SRAM_BSS uint8_t aot_v_cdc_tx_ff_buf[TFLM_VALIDATOR_TX_BUFSIZE] __attribute__((aligned(4)));

#if (configAPPLICATION_ALLOCATED_HEAP == 1)
size_t ucHeapSize = (NS_RPC_MALLOC_SIZE_IN_K + 8) * 1024;
NS_SRAM_BSS uint8_t ucHeap[(NS_RPC_MALLOC_SIZE_IN_K + 8) * 1024] __attribute__((aligned(4)));
#endif

// -------------------------- Optional profiling bits -------------------------
#ifdef NS_MLPROFILE
ns_timer_config_t s_tickTimer = { .api = &ns_timer_V1_0_0, .timer = NS_TIMER_COUNTER, .enableInterrupt = false };
#if defined(AM_PART_APOLLO5B) || defined(AM_PART_APOLLO510L)
ns_pmu_config_t   s_pmu_cfg;
extern ns_pmu_config_t ns_microProfilerPMU;

#endif
#endif

// Provide a stats hook implementation expected by validator_rpc.c
void vrpc_on_after_invoke(void) {
  // AOT uses a runtime callback to mark per-op boundaries and measure time.
  // Export per-layer time (microseconds) through the normal stats path.
  extern uint32_t    ns_aot_layer_count(void);
  extern const uint32_t* ns_aot_layer_elapsed_us(void);
  const uint32_t n = ns_aot_layer_count();
  const uint32_t* us = ns_aot_layer_elapsed_us();

  // Guard against overflow of the stats buffer; truncate if ever needed.
  const uint32_t bytes = n * sizeof(uint32_t);
  const uint32_t max_bytes = sizeof(mut_stats.stats.stat_buffer);
  const uint32_t to_copy = (bytes <= max_bytes) ? bytes : max_bytes;

  // Describe the payload to the host: one 32-bit value per layer in order.
  mut_stats.stats.captured_events = n;
  mut_stats.stats.computed_stat_per_event_size = sizeof(uint32_t);
  memset(mut_stats.stats.csv_header, 0, sizeof(mut_stats.stats.csv_header));
  
  // Simple CSV header understood by the host side: "layer,us"
  const char *hdr = "layer,us";
  memcpy(mut_stats.stats.csv_header, hdr, strlen(hdr));
  memset(mut_stats.stats.stat_buffer, 0, sizeof(mut_stats.stats.stat_buffer));
  memcpy((void*)mut_stats.stats.stat_buffer, (const void*)us, to_copy);

  #if defined(AM_PART_APOLLO5B) || defined(AM_PART_APOLLO510L)
  // If the host asked for full PMU capture, advertise PMU availability so that
  // the fetch path can switch to per-layer PMU streaming after FullStats.
  if (mut_cfg.config.full_pmu_stats == 1) {
    mut_stats.stats.pmu_count = NS_NUM_PMU_MAP_SIZE;
  } else {
    mut_stats.stats.pmu_count = 0;
  }
#else
  mut_stats.stats.pmu_count = 0;
#endif

}

int main(void) {
  ns_core_config_t core_cfg = {.api = &ns_core_V1_0_0};
  NS_TRY(ns_core_init(&core_cfg), "Core init failed");
  NS_TRY(ns_power_config(&ns_development_default), "Power Init Failed");
  ns_itm_printf_enable();
#ifdef NS_MLPROFILE
  // Timer for profiling timestamps
  NS_TRY(ns_timer_init(&s_tickTimer), "Timer init failed");
#if defined(AM_PART_APOLLO5B) || defined(AM_PART_APOLLO510L)
  // Minimal PMU setup; detailed event selection handled in debug log module
  s_pmu_cfg.api = &ns_pmu_V1_0_0;
  ns_pmu_reset_config(&s_pmu_cfg);
  // Map 4 events (the exact mapping can be overridden in the metadata header)
  ns_pmu_event_create(&s_pmu_cfg.events[0], NS_PROFILER_PMU_EVENT_0, NS_PMU_EVENT_COUNTER_SIZE_32);
  ns_pmu_event_create(&s_pmu_cfg.events[1], NS_PROFILER_PMU_EVENT_1, NS_PMU_EVENT_COUNTER_SIZE_32);
  ns_pmu_event_create(&s_pmu_cfg.events[2], NS_PROFILER_PMU_EVENT_2, NS_PMU_EVENT_COUNTER_SIZE_32);
  ns_pmu_event_create(&s_pmu_cfg.events[3], NS_PROFILER_PMU_EVENT_3, NS_PMU_EVENT_COUNTER_SIZE_32);
  ns_pmu_init(&s_pmu_cfg);
  // Copy to ns_microProfilerPMU
  memcpy(&ns_microProfilerPMU, &s_pmu_cfg, sizeof(ns_pmu_config_t));
#endif
#endif
  ns_mem_init_defaults();

#if (TFLM_MODEL_LOCATION == NS_AD_PSRAM) || (TFLM_ARENA_LOCATION == NS_AD_PSRAM)
  // Initialize PSRAM and inform memory provider
  ns_psram_config_t psram_cfg = {
    .api = &ns_psram_V0_0_1,
    .psram_enable = true,
    .psram_type = PSRAM_TYPE_HEX,
  #ifdef apollo510_evb
    .psram_block = 0,
  #else
    .psram_block = 3,
  #endif
    .psram_size = 0,
    .psram_base_address = 0,
  };
  NS_TRY(ns_psram_init(&psram_cfg), "PSRAM Init Failed");
  ns_mem_set_psram_base((uint8_t*)psram_cfg.psram_base_address);
#endif

  ns_interrupt_master_enable();

#if (NS_VALIDATOR_RPC_TRANSPORT == NS_AD_RPC_TRANSPORT_UART)
  ns_uart_config_t rpcUARTHandle = {
      .api = &ns_uart_V0_0_1,
      .uart_config = NULL,
      .rx_cb = NULL,
      .tx_cb = NULL,
      .tx_blocking = true,
      .rx_blocking = true };
#endif

  ns_rpc_config_t rpc_cfg = {
    .api = &ns_rpc_gdo_V1_1_0,
    .mode = NS_RPC_GENERICDATA_SERVER,
    .rx_buf = aot_v_cdc_rx_ff_buf,
    .rx_bufLength = TFLM_VALIDATOR_RX_BUFSIZE,
    .tx_buf = aot_v_cdc_tx_ff_buf,
    .tx_bufLength = TFLM_VALIDATOR_TX_BUFSIZE,
#if (NS_VALIDATOR_RPC_TRANSPORT == NS_AD_RPC_TRANSPORT_UART)
    .uartHandle = (ns_uart_handle_t)&rpcUARTHandle,
    .transport = NS_RPC_TRANSPORT_UART,
#else
    .uartHandle = NULL,
    .transport = NS_RPC_TRANSPORT_USB,
#endif
    .sendBlockToEVB_cb   = decodeIncomingSendblock,
    .fetchBlockFromEVB_cb= decodeIncomingFetchblock,
    .computeOnEVB_cb     = infer,
  };
  NS_TRY(ns_rpc_genericDataOperations_init(&rpc_cfg), "RPC Init Failed");

  ns_lp_printf("[AOT] Ready to receive RPC Calls");
  while (1) {
    ns_rpc_genericDataOperations_pollServer(&rpc_cfg);
    ns_delay_us(1000);
  }
}